<!DOCTYPE html><html lang="en-US"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><title> - rRNA maturation</title><link rel="shortcut icon" href="/rRNA_maturation/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/rRNA_maturation/assets/css/just-the-docs-default.css"> <script src="/rRNA_maturation/assets/js/vendor/lunr.min.js"></script> <script src="/rRNA_maturation/assets/js/just-the-docs.js"></script><meta name="viewport" content="width=device-width, initial-scale=1"><title>rRNA maturation | Insights into rRNA processing and modifications in Archaea using Nanopore-based RNA sequencing</title><meta name="generator" content="Jekyll v3.9.0" /><meta property="og:title" content="rRNA maturation" /><meta property="og:locale" content="en_US" /><meta name="description" content="Insights into rRNA processing and modifications in Archaea using Nanopore-based RNA sequencing" /><meta property="og:description" content="Insights into rRNA processing and modifications in Archaea using Nanopore-based RNA sequencing" /><link rel="canonical" href="http://localhost:4000/rRNA_maturation/assets/js/search-data/" /><meta property="og:url" content="http://localhost:4000/rRNA_maturation/assets/js/search-data/" /><meta property="og:site_name" content="rRNA maturation" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="rRNA maturation" /> <script type="application/ld+json"> {"@type":"WebPage","url":"http://localhost:4000/rRNA_maturation/assets/js/search-data/","headline":"rRNA maturation","description":"Insights into rRNA processing and modifications in Archaea using Nanopore-based RNA sequencing","@context":"https://schema.org"}</script><body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"><title>Link</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"><title>Search</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"><title>Menu</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"><title>Expand</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"><title>Document</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg><div class="side-bar"><div class="site-header"> <a href="http://localhost:4000/rRNA_maturation/" class="site-title lh-tight"> rRNA maturation </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a></div><nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"><ul class="nav-list"><li class="nav-list-item"><a href="/rRNA_maturation/" class="nav-list-link">About</a><li class="nav-list-item"><a href="/rRNA_maturation/project" class="nav-list-link">Project</a><li class="nav-list-item"><a href="/rRNA_maturation/sample_preparation/" class="nav-list-link">Sample preparation</a><li class="nav-list-item"><a href="/rRNA_maturation/sequencing/" class="nav-list-link">Sequencing</a><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Processing analysis category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/rRNA_maturation/processing_analysis/" class="nav-list-link">Processing analysis</a><ul class="nav-list "><li class="nav-list-item "><a href="/rRNA_maturation/processing_analysis/Basecalling/" class="nav-list-link">Basecalling and demultiplexing of raw reads</a><li class="nav-list-item "><a href="/rRNA_maturation/processing_analysis/read_alignment/" class="nav-list-link">Read alignment</a></ul><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Modified base detection category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/rRNA_maturation/mod_base/" class="nav-list-link">Modified base detection</a><ul class="nav-list "></ul><li class="nav-list-item"><a href="/rRNA_maturation/data/" class="nav-list-link">Data</a><li class="nav-list-item"><a href="/rRNA_maturation/contact/" class="nav-list-link">Contact</a></ul></nav><footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</footer></div><div class="main" id="top"><div id="main-header" class="main-header"><div class="search"><div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search rRNA maturation" aria-label="Search rRNA maturation" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label></div><div id="search-results" class="search-results"></div></div><nav aria-label="Auxiliary" class="aux-nav"><ul class="aux-nav-list"><li class="aux-nav-list-item"> <a href="//github.com/felixgrunberger/rRNA_maturation" class="site-button" > Workflow on GitHub </a></ul></nav></div><div id="main-content-wrap" class="main-content-wrap"><div id="main-content" class="main-content" role="main"><p>{ “0”: { “id”: “0”, “title”: “”, “content”: “404 Page not found :( The requested page could not be found.”, “url”: “http://localhost:4000/rRNA_maturation/404.html”, “relUrl”: “/404.html” }, “1”: { “id”: “1”, “title”: “Basecalling and demultiplexing of raw reads”, “content”: “Basecalling and demultiplexing of raw reads Basecalling of raw reads using guppy_basecaller Demultiplexing of basecalled reads using guppy_barcoder For better comparability we re-basecalled the FAST5 file from all runs using the same version on guppy on a Mk1C (ont-guppy-for-mk1c v4.3.4) Once the Mk1C is set up correctly and connected to the internet, updates are displayed automatically and can be completed by click Other software downloads are available from the ONT downloads page Basecalling of raw reads using guppy_basecaller After sequencing (and despite live-basecalling) all datasets in the raw_FAST5 folder were re-basecalled using guppy (ont-guppy-for-mk1c v4.3.4) in high-accuracy mode (rna_r9.4.1<em>70bps_hac.cfg, dna_r9.4.1_450bps_hac.cfg) without quality filtering The output files in FASTQ format were written to the basecalled folder. Note: Mk1C We (and others) noticed the apparently acces via GUI is not the fastest way to perform basecalling In case you want to optimise GPU-accelerated basecalling on the Mk1C (settings for NVIDIA Jetson TX2) using have a look at Miles Benton`s GitHub According this his suggestions (which really speed up the process), we performed basecalling like this (using ssh access to the Mk1C): # files input=microbepore/data/raw_FAST5/run_id # add run id output_DRS=microbepore/data/FASTQ/normal/run_id # add run id output_cDNA=microbepore/data/basecalled/run_id # add run id # Basecalling of DRS files guppy_basecaller –input_path ${input} # input path –save_path ${output_DRS} # output path -c rna_r9.4.1_70bps_hac.cfg # config file: high accuracy RNA –calib_detect # detect calibration spike-in –reverse_sequence true # reverse since sequenced 3´–&gt;5´ –u_substitution true # replace U´s with T´s –compress_fastq # compress output –fast5_out # output FAST5 –recursive # look for FAST5 recursively in path –progress_stats_frequency 60 # output progress every minute –chunks_per_runner 256 # options for Mk1C –gpu_runners_per_device 4 # options for Mk1C –num_callers 1 # options for Mk1C -x auto # options for Mk1C # Basecalling of cDNA files guppy_basecaller –input_path ${input} –save_path ${output_cDNA} -c dna_r9.4.1_450bps_hac.cfg # config file: high accuracy cDNA –compress_fastq –fast5_out –recursive –progress_stats_frequency 60 –chunks_per_runner 256 –gpu_runners_per_device 4 –num_callers 1 -x auto Note: DRS &amp; (PCR-)cDNA runs require different options. Config file selection based on selected accuracy, flowcell version, library preparation kit are listed with guppy_basecaller –print_workflows Since basecalling is probably taking quite a while, but you want to keep the process running without interruption you can use the nohup command. You can use it like nohup guppy_basecaller ….. &amp;. This starts basecalling using guppy and puts to process in the background (that´s what the &amp; does). Now, you can log out from the Mk1C and the process keeps running. To monitor the process you can check the shell output that is written to nohup.out. With the selected options guppy produces fast5_pass, fast5_fail, fastq, summary and report files that are written to the FASTQ folder. FASTQ are not grouped in pass and fail groups since –min_qscore is not enabled. Multiple FASTQs can be merged using cat microbepore/data/basecalled/run_id/*.fastq &gt; microbepore/data/basecalled/run_id/run_id.fastq. Sequencing summary files are also written to the FASTQ folder and are used during the quality control of the runs and reads. For better viewing they can be moved to the summary folder using mv microbepore/data/FASTQ/run_id/sequencing_summary.txt microbepore/data/summary/run_id.txt Demultiplexing of basecalled reads using guppy_barcoder Next, multiplexed cDNA libraries are demultiplexed in a separate step using guppy_barcoder. # files input=microbepore/data/basecalled/run_id # add run id output=microbepore/data/FASTQ/normal/run_id # add run id # Demultiplexing of (PCR-)cDNA files guppy_barcoder –input_path ${input} –save_path ${output} –config configuration.cfg –barcode_kits SQK-PCB109 –progress_stats_frequency 60 Multiple FASTQs are written to the FASTQ folder and can be merged with e.g. cat microbepore/data/FASTQ/run_id/barcode01/*.fastq &gt; microbepore/data/FASTQ/run_id/run_id_barcode01.fastq. Barcode summary files are written to the FASTQ folder and can be moved to the barcode folder.”, “url”: “http://localhost:4000/rRNA_maturation/processing_analysis/Basecalling/”, “relUrl”: “/processing_analysis/Basecalling/” }, “2”: { “id”: “2”, “title”: “Contact”, “content”: “Get in touch We would like to get in touch you! If you have any questions, feedback or suggestions, we would be happy to start a discussion with you at GitHub Discussions.”, “url”: “http://localhost:4000/rRNA_maturation/contact/”, “relUrl”: “/contact/” }, “3”: { “id”: “3”, “title”: “Data”, “content”: “Data To facilitate easier access basecalled and demultiplexed FASTQ, mapped BAM files from untrimmed reads and large read summary files are publicly available from a Google Drive folder. Scripts All scripts and code used in this work are available on GitHub Original FAST5 data Sequencing files in original FAST5 format are publicly available in the Sequence Read Archive SRA (RNA001: PRJNA632538, all other datasets: PRJNA731531).”, “url”: “http://localhost:4000/rRNA_maturation/data/”, “relUrl”: “/data/” }, “4”: { “id”: “4”, “title”: “Processing analysis”, “content”: “Data analysis Here, you can find a description of the workflow using publicly available tools used to basecall, demultiplex, trim, map and count data. Additionally, we comment on custom Rscripts we used to perform the downstream analysis, including quality control, annotation of transcript boundaries, gene body coverage analysis and transcriptional unit annotation.”, “url”: “http://localhost:4000/rRNA_maturation/processing_analysis/”, “relUrl”: “/processing_analysis/” }, “5”: { “id”: “5”, “title”: “Gene body coverage”, “content”: “Gene body coverage analysis Preparation of ONT-annotated transcript files Calculation of coverage using bedtools coverage Downstream R analysis To assess the impact of trimmings on gene body coverage, a coverage meta-analysis was performed Preparation of ONT-annotated transcript files First, a transcript file was created for all genes with an ONT-annotated primary 5´ and 3´ end (see previous section) Calculation of coverage using bedtools coverage Based on this, strand-specific coverage files were created from the BAM files input=microbepore/data/mapped # calculate coverage over transcripts with TSS and TTS | for pychopper auto &gt; cutadapt &gt; clipped or RAW for file in ${input}/trimmed/*/*/*clipped.sorted.bam # || for file in ${input}/raw/*/*/*.sorted.bam do filename_extended=${file##*/} keyword=$(echo $filename_extended | cut -d"." -f 2) foldername=$(echo $filename_extended | cut -d"</em>" -f 1,2,3) filename=${filename_extended%%.<em>} # mk dirs mkdir microbepore/data/coverage/trimmed mkdir microbepore/data/coverage/trimmed/${foldername} output=microbepore/data/coverage/trimmed/${foldername}/${filename} mkdir ${output} # calc coverage samtools view -F 16 -o temp.sorted.bam ${file} bedtools coverage -d -a ${dir}/data/bed/transcripts.plus.bedgraph # bed file of genes with annotated 5´and 3´end -b temp.sorted.bam &gt; ${output}/${filename}.plus.coverage samtools view -f 16 -o temp.sorted.bam ${file} bedtools coverage -d -a ${dir}/data/bed/transcripts.minus.bedgraph # bed file of genes with annotated 5´and 3´end -b temp.sorted.bam &gt; ${output}/${filename}.minus.coverage done Downstream R analysis Coverage analysis performed using a custom R script.”, “url”: “http://localhost:4000/rRNA_maturation/processing_analysis/gene_body/”, “relUrl”: “/processing_analysis/gene_body/” }, “6”: { “id”: “6”, “title”: “Identification and trimming of full-length reads”, “content”: “Trimming of reads using pychopper, cutadapt &amp; samclip Identification of full-length reads using pychopper Remove polyA-tails using cutadapt Remove remaining SSP adapter using cutadapt Mapping of trimmed reads, removing clips using samclip Identification of full-length reads using pychopper Full-length cDNA reads containing SSP and VNP primers in the correct orientation were identified using pychopper (v.2.5.0) with standard parameters using the default pHMM backend and autotuned cutoff parameters estimated from subsampled data Save output in pychopper folder. # files input=microbepore/data/FASTQ/normal # input directory with all merged FASTQ files, 1 for each barcode or single DRS run # perform pychopper for all cDNA and (PCR)-cDNA files for file in ${input}/</em>/<em>.fastq do # folder and filenames f_ex=${file##</em>/} foldername=$(echo $f_ex | cut -d"<em>" -f 1,2,3) filename=${f_ex%%.*} # make directories mkdir microbepore/data/pychopper/normal mkdir microbepore/data/pychopper/normal/${foldername} output=microbepore/data/pychopper/normal/${foldername}/${filename} mkdir ${output} # perform pychopper using precomputed q cdna_classifier.py -r ${output}/${filename}_report.pdf -t 8 -u ${output}/${filename}_unclassified.fastq -w ${output}/${filename}_rescued.fastq -S ${output}/${filename}_stats.txt $file ${output}/${filename}_full_length_output.fastq done After a first round, a second round of pychopper was applied to the unclassified direct cDNA reads with DCS-specific read rescue enabled. # files input=microbepore/data/pychopper/normal # input directory with all merged FASTQ files, 1 for each barcode or single DRS run # perform pychopper using the -x rescue option for DCS files for file in ${input}/*unclassified.fastq # only use unclassified reads from first round as input do # folder and filenames filename_extended=${file##*/} foldername=$(echo $filename_extended | cut -d"</em>" -f 1,2,3) filename=${filename_extended%%.<em>} # make directories mkdir ${dir}/data/pychopper/rescued mkdir ${dir}/data/pychopper/rescued/${foldername} output=microbepore/data/pychopper/rescued/${foldername}/${filename} mkdir ${output} # perfrom pychopper using -X option for native cDNA datasets cdna_classifier.py -r ${output}/${filename}_report.pdf -t 8 -x rescue -u ${output}/${filename}_unclassified.fastq -w ${output}/${filename}_rescued.fastq -S ${output}/${filename}_stats.txt $file ${output}/${filename}_full_length_output.fastq done Reads from rescued and normal folders were merged and used for subsequent steps. # files input=microbepore/data/pychopper/ # merge all full-length and rescued reads as full-length for file in ${input}/normal/</em>/<em>/</em>full_length_output.fastq # both normal and rescued folders do filename_extended=${file##<em>/} foldername=$(echo $filename_extended | cut -d"_" -f 1,2,3) filename=$(echo $filename_extended | cut -d"_" -f 1,2,3,4,5) keyword=$(echo $foldername | cut -d"_" -f 2) # get libary kit ID mkdir microbepore/data/FASTQ/full_length mkdir microbepore/data/FASTQ/full_length/${foldername} output=microbepore/data/FASTQ/full_length/${foldername}/${filename} mkdir ${output} if [[ $keyword =~ "PCB109" ]]; then cat $file ${input}/normal/${foldername}/${filename}/${filename}_rescued.fastq &gt; ${output}/${filename}_full_length_all.fastq elif [[ $keyword =~ "DCS109" ]]; then cat $file ${input}/normal/${foldername}/${filename}/${filename}_rescued.fastq ${input}/rescued/${foldername}/${filename}_unclassified/${filename}_unclassified_full_length_output.fastq ${input}/rescued/${foldername}/${filename}_unclassified/${filename}_unclassified_rescued.fastq &gt; ${output}/${filename}_full_length_all.fastq fi done For easier handling in the subsequent steps, DRS FASTQ files are also moved to the microbepore/data/FASTQ/full_length folder and adding _full_length_all to the filename. Remove polyA-tails using cutadapt To evaluate the influence of different trimming approaches on the accuracy of transcript boundary analysis, we applied additional 5´ and 3´ trimming steps using cutadapt v3.2 To this end, polyA sequences were removed from the 3´ends: # files input=microbepore/data/FASTQ/full_length # input directory with all merged FASTQ files, 1 for each barcode or single DRS run for file in ${input}/</em>/<em>/</em><em>full_length_all.fastq do # folder and filenames filename_extended=${file##*/} keyword=$(echo $filename_extended | cut -d"." -f 2) foldername=$(echo $filename_extended | cut -d"</em>" -f 1,2,3) filename=${filename_extended%%.<em>} mkdir microbepore/data/FASTQ/cutadapt mkdir microbepore/data/FASTQ/cutadapt/${foldername} output=microbepore/data/FASTQ/cutadapt/${foldername}/${filename} mkdir ${output} # cutadapt cutadapt -a "A{10}" # trim polyAs longer than 10 bases from the 3´end -e 1 # allowed error rate -j 0 # auto-detect cores -o ${output}/${filename}.cutadapt.fastq ${file} done Remove remaining SSP adapter using cutadapt Remove remaining SSP sequences from the 5´ends of the cDNA reads using: input=microbepore/data/FASTQ/cutadapt # &gt; SSP adapter for file in ${input}/</em>/<em>/</em>cutadapt.fastq do filename_extended=${file##<em>/} keyword=$(echo $filename_extended | cut -d"." -f 2) foldername=$(echo $filename_extended | cut -d"_" -f 1,2,3) filename=${filename_extended%%.</em>} mkdir microbepore/data/FASTQ/cutadapt_SSP mkdir microbepore/data/FASTQ/cutadapt_SSP/${foldername} output=microbepore/data/FASTQ/cutadapt_SSP/${foldername}/${filename} mkdir ${output} cutadapt -g "TTTCTGTTGGTGCTGATATTGCTGGG" -e 1 -j 0 -o ${output}/${filename}.cutadapt_SSP.fastq ${file} done Mapping of trimmed reads, removing clips using samclip Finally, trimmed reads were mapped using minimap2 as described before Reads with more than 10 clipped bases on either side were removed from the alignments using samclip (v.0.4.0) Step: Align input=microbepore/data/FASTQ/cutadapt_SSP fasta=microbepore/data/genome/NC_000913.3.fasta # downloaded from GenBank # map (pychopper) &gt; polyA_trimmed &gt; SSP trimmed fastqs for file in ${input}/<em>/</em>/<em>fastq do filename_extended=${file##</em>/} foldername=$(echo ${filename_extended} | cut -d"<em>" -f 1,2,3) filename=${filename_extended%%.*} mkdir microbepore/data/mapped/adapter_trimmed mkdir microbepore/data/mapped/adapter_trimmed/${foldername} output=microbepore/data/mapped/adapter_trimmed/${foldername}/${filename} mkdir ${output} ## align using minimap2 if [[ $filename =~ "RNA" ]]; then # align using minimap2 minimap2 -ax splice -p 0.99 -uf -k14 –MD -t 8 ${fasta} ${file} &gt; ${output}/${filename}.sam else minimap2 -ax splice -p 0.99 -k14 –MD -t 8 ${fasta} ${file} &gt; ${output}/${filename}.sam fi done Step: Remove clipping &gt; 10 bases input=microbepore/data/mapped/adapter_trimmed fasta=microbepore/data/genome/NC_000913.3.fasta # downloaded from GenBank transcripts=microbepore/data/genomeNC_000913.3.transcripts.fasta # transcripts file made using gffread # remove reads with more than 10 bases that are clipped on either side. for file in ${input}/*/*/*.sam do filename_extended=${file##*/} keyword=$(echo $filename_extended | cut -d"." -f 2) foldername=$(echo $filename_extended | cut -d"</em>" -f 1,2,3) filename=${filename_extended%%.<em>} if [[ $keyword =~ "sam" ]]; then echo ${foldername} echo ${filename} echo ${keyword} mkdir microbepore/data/mapped/trimmed mkdir microbepore/data/mapped/trimmed/${foldername} output=microbepore/data/mapped/trimmed/${foldername}/${filename} mkdir ${output} # remove mapped reads with a Maximum clip length to allow (10, 5 is default) samclip –max 10 –ref ${fasta} &lt; ${file} &gt; ${output}/${filename}.clipped.sam # convert to sorted.bam file samtools flagstat ${output}/${filename}.clipped.sam &gt; ${output}/${filename}.clipped.stats.txt samtools view -bS ${output}/${filename}.clipped.sam -o ${output}/${filename}.clipped.bam samtools sort ${output}/${filename}.clipped.bam -o ${output}/${filename}.clipped.sorted.bam samtools index ${output}/${filename}.clipped.sorted.bam ## remap fastq converted reads bedtools bamtofastq -i ${output}/${filename}.clipped.sorted.bam -fq ${output}/${filename}.remapped.fastq ## map again if [[ $filename =~ "RNA" ]]; then # align using minimap2 minimap2 -ax splice -p 0.99 -uf -k14 –MD -t 8 ${transcripts} ${file} &gt; ${output}/${filename}.remapped.sam else minimap2 -ax splice -p 0.99 -k14 –MD -t 8 ${transcripts} ${file} &gt; ${output}/${filename}.remapped.sam fi # convert to sorted.bam file samtools view -bS ${output}/${filename}.remapped.sam -o ${output}/${filename}.remapped.bam samtools sort ${output}/${filename}.remapped.bam -o ${output}/${filename}.remapped.sorted.bam samtools index ${output}/${filename}.remapped.sorted.bam fi done”, “url”: “http://localhost:4000/rRNA_maturation/processing_analysis/identification_full_length/”, “relUrl”: “/processing_analysis/identification_full_length/” }, “7”: { “id”: “7”, “title”: “About”, “content”: “Insights into rRNA processing and modifications in Archaea using Nanopore-based RNA sequencing Here we describe tools and custom R scripts to analyse rRNA processing and modification in Archaea using Nanopore-based direct cDNA and direct RNA sequencing. If you´re interested you can read our previous pre-print on biorxiv: Exploring prokaryotic transcription, operon structures, rRNA maturation and modifications using Nanopore-based native RNA sequencing. Processing analysis Modified base detection Find the code on GitHub The repository is currently actively developed.”, “url”: “http://localhost:4000/rRNA_maturation/”, “relUrl”: “/” }, “8”: { “id”: “8”, “title”: “Modified base detection”, “content”: “Modified base detection Here, you can find a description of the workflow using publicly available tools used to basecall, demultiplex, trim, map and count data. Additionally, we comment on custom Rscripts we used to perform the downstream analysis, including quality control, annotation of transcript boundaries, gene body coverage analysis and transcriptional unit annotation.”, “url”: “http://localhost:4000/rRNA_maturation/mod_base/”, “relUrl”: “/mod_base/” }, “9”: { “id”: “9”, “title”: “Transcriptional unit analysis”, “content”: “Transcriptional unit analysis”, “url”: “http://localhost:4000/rRNA_maturation/processing_analysis/operon_detection/”, “relUrl”: “/processing_analysis/operon_detection/” }, “10”: { “id”: “10”, “title”: “Project”, “content”: “Project At the beginning of this project, there was no comprehensive analysis of Nanopore sequencing of RNA and cDNA molecules using 3rd generation Nanopore technology in prokaryotes available. Therefore, the aim of this study was to benchmark current RNA-seq protocols provided by Oxford Nanopore Technologies (ONT) using Escherichia coli as one of the most popular bacterial model organisms. We were especially interested, how well Nanopore sequencing captures multiple transcriptomic features at once and how the data compare to similar protocols, like SMRT-Cappable-seq. In this documentation, we would like give a more detailed description of things to consider for sample preparation and sequencing and guide you through the individual steps of the data analysis using tools and scripts developed by ONT, many other developers and custom R workflows. Experimental design We evaluated the performance of all RNA-seq protocols currently available from ONT, namely: DRS: Direct sequencing of native RNAs (using SQK-RNA001 &amp; SQK-RNA002) cDNA: Direct sequencing of cDNAs (using SQK-DCS109) PCR-cDNA: Sequencing of PCR-amplifed cDNAs (using SQK-PCB109)”, “url”: “http://localhost:4000/rRNA_maturation/project”, “relUrl”: “/project” }, “11”: { “id”: “11”, “title”: “Project organisation”, “content”: “Project organisation It is good practice to keep all files for your project in the same project-specific folder. A well-organised folder structure helps you to have a good overview and facilitates access to the files. For project standardisation and folder creation you can use something like project templates in R or make your own structure. For example, our project for the RNA-seq analysis looks something like this: microbepore/ ├── doc/ ├── … ├── … └── … ├── pipeline/ ├── … ├── … └── … ├── Rscripts/ ├── … ├── … └── … ├── data/ ├── … ├── … └── … ├── microbepore.Rproj/ ├── README.Rmd/ └── LICENSE/ One thing that really helps setting up your R session for a better workflow (especially if you are new to working with many data &amp; if you like to work with R) is setting all up in an RStudio project and using the here package that makes it easier to reference folders. A demonstration of the benefits can be found in Jenny Bryan´s GitHub.”, “url”: “http://localhost:4000/rRNA_maturation/processing_analysis/project_organization/”, “relUrl”: “/processing_analysis/project_organization/” }, “12”: { “id”: “12”, “title”: “Quality control”, “content”: “Quality control Raw reads Mapped reads Raw reads Mapped reads”, “url”: “http://localhost:4000/rRNA_maturation/processing_analysis/qc_raw_reads/”, “relUrl”: “/processing_analysis/qc_raw_reads/” }, “13”: { “id”: “13”, “title”: “Gene abundance estimation”, “content”: “Gene abundance estimation To estimate gene abundances salmon (v.1.4.0) was applied in alignment-based mode as described in https://salmon.readthedocs.io/en/latest/salmon.html#quantifying-in-alignment-based-mode For installation you can follow the explanations listed at https://combine-lab.github.io/salmon/getting_started/ (installs salmon in own conda environment) input=microbepore/data/mapped/raw # input directory with all remapped files for file in ${input}/</em>/<em>/</em>remapped.sorted.bam do # folder and filenames f_ex=${file##<em>/} foldername=$(echo ${f_ex} | cut -d"_" -f 1,2,3) filename=${f_ex%%.</em>} # create dir for quantification using salmon in alignment-based mode (e.g. used in conda environment) mkdir microbepore/data/salmon mkdir microbepore/data/salmon/${foldername} output=microbepore/data/salmon/${foldername}/${filename} mkdir ${output} conda activate salmon # activate conda environment # use salmon in alignment-based mode salmon quant -t ${transcripts} -l A -a ${file} -o ${output} –threads 8 conda deactivate done Transcripts per million (TPM) were re-calculated using the salmon-computed effective transcript length, after dropping reads mapping to rRNAs, that are variable between non-depleted and depleted RNA sets (compare custom Rscripts/salmon_analysis.R). Calculation of custom TPMs is performed in the modify_salmon_output function: modify_salmon_output &lt;- function(input, method){ # read in salmon output suppressMessages(vroom(input, num_threads = 8)) %&gt;% # sort by Number of reads mapping arrange(desc(NumReads)) %&gt;% # read in salmon output # rename columns mutate(counts = NumReads, gene = Name, salmon_tpm = TPM) %&gt;% # drop all rRNAs dplyr::filter(!gene %in% names_rRNA) %&gt;% # select columns select(counts, gene, salmon_tpm,EffectiveLength) %&gt;% # rename genes mutate(gene = str_split_fixed(gene,"-",2)[,2]) %&gt;% # sort by number of counts arrange(desc(counts)) %&gt;% # add gene information (including with to table) left_join(ecoli_gff, by = "gene") %&gt;% # make RNA type categories mutate(type_fine = ifelse(type == "rRNA", as.character(locus_name), as.character(type)), type_fine = ifelse(type == "tRNA", "ncRNA", as.character(type_fine))) %&gt;% # calculate RPK from salmon-calculated effectiveLength, TPM(hand) = RPK/sum(RPK)/1000000, additionally calc RPKM mutate(sample = method, rpk = (counts/EffectiveLength<em>1000), TPM_hand = rpk/(sum(rpk, na.rm = T)/1000000), rpkm = (counts/(sum(counts)/1000000))/width</em>1000) %&gt;% # TPM_hand is the value used dplyr::select(gene, type_fine, counts, sample,rpkm, TPM_hand, salmon_tpm) }”, “url”: “http://localhost:4000/rRNA_maturation/processing_analysis/quantification/”, “relUrl”: “/processing_analysis/quantification/” }, “14”: { “id”: “14”, “title”: “Read alignment”, “content”: “Read alignment Genome files Mapping of reads to the genome using minimap2 Genome files Genome FASTA and GFF3 files have been downloaded from GenBank Transcript file was made using gffread with gffread microbepore/data/genome/NC_000913.3.gff -g microbepore/data/genome/NC_000913.3.fasta -w microbepore/data/genome/NC_000913.3.transcripts.fasta Mapping of reads to the genome using minimap2 Files were mapped to the reference genome from Escherichia coli K-12 MG1655 (GenBank: U00096.3) using minimap2 (Release 2.18-r1015) Output alignments in the SAM format were generated with -ax splice -k14 for Nanopore cDNA-seq and -ax splice, -uf, -k14 for DRS with i) -p 0.99, to return primary and secondary mappings and ii) with –MD, to include the MD tag for calculating mapping identities Alignment files were further converted to BAM files, sorted and indexed using [SAMtools(https://github.com/samtools/) To analyse single reads in more detail with respect to the RNA type (mRNA, rRNA, other ncRNA, unspecified) they map to, BAM files were first converted back to FASTQ using bedtools v2.29.2 Next FASTQ files were remapped to a transcriptome file using minimap2 with the previously mentioned parameters to assign single read names with feature IDs # files input=microbepore/data/FASTQ/normal # input directory with all merged FASTQ files, 1 for each barcode or single DRS run fasta=microbepore/data/genome/NC_000913.3.fasta # downloaded from GenBank transcripts=microbepore/data/genomeNC_000913.3.transcripts.fasta # transcripts file made using gffread # Mapping &amp; Remapping - loop through all FASTQs for file in ${input}/<em>/</em>.fastq do # folder and filenames f_ex=${file##<em>/} foldername=$(echo ${f_ex} | cut -d"_" -f 1,2,3) # depending on how you name your files filename=${f_ex%%.</em>} # make directories mkdir microbepore/data/mapped/raw # direct output to mapped folder for raw reads mkdir microbepore/data/mapped/raw/${foldername} # run_id output=microbepore/data/mapped/raw/${foldername}/${filename} # run_id/barcode_id mkdir ${output} if [[ $filename =~ "RNA" ]]; then # align using minimap2 minimap2 -ax splice -p 0.99 -uf -k14 –MD -t 8 ${fasta} ${file} &gt; ${output}/${filename}.sam # DRS else minimap2 -ax splice -p 0.99 -k14 –MD -t 8 ${fasta} ${file} &gt; ${output}/${filename}.sam # (PCR-)cDNA fi # convert to sorted.bam file samtools view -bS ${output}/${filename}.sam -o ${output}/${filename}.bam samtools sort ${output}/${filename}.bam -o ${output}/${filename}.sorted.bam samtools index ${output}/${filename}.sorted.bam # bam to fastq for remapping of mapped reads bedtools bamtofastq -i ${output}/${filename}.sorted.bam -fq ${output}/${filename}.remapped.fastq # map again if [[ $filename =~ "RNA" ]]; then minimap2 -ax splice -p 0.99 -uf -k14 –MD -t 8 ${transcripts} ${output}/${filename}.remapped.fastq &gt; ${output}/${filename}.remapped.sam else minimap2 -ax splice -p 0.99 -k14 –MD -t 8 ${transcripts} ${output}/${filename}.remapped.fastq &gt; ${output}/${filename}.remapped.sam fi # convert to sorted.bam file samtools view -bS ${output}/${filename}.remapped.sam -o ${output}/${filename}.remapped.bam samtools sort ${output}/${filename}.remapped.bam -o ${output}/${filename}.remapped.sorted.bam samtools index ${output}/${filename}.remapped.sorted.bam done”, “url”: “http://localhost:4000/rRNA_maturation/processing_analysis/read_alignment/”, “relUrl”: “/processing_analysis/read_alignment/” }, “15”: { “id”: “15”, “title”: “Sample preparation”, “content”: “Sample preparation Cell growth and RNA extraction Poly(A) tailing, rRNA depletion and additional RNA treatment Library preparation Cell growth and RNA extraction Grow Escherichia coli K-12 MG1655 cells in rich medium (10 g tryptone, 5 g yeast extract, 5 g NaCl per liter, pH 7.2) to an OD600nm of 0.5-0.6 (or your organism of choice in the conditions you´re interested in) Stabilize RNAs by adding two volumes of RNAlater (Thermo Fisher Scientific) Store cultures at -20°C or harvest cells by centrifugation at 4°C Extract RNA with the method of your choice. We (and others) had good experience with the RNeasy Kit from Qiagen Note: Silica-membrane columns have a cut-off size of about 200 nucleotides Check integrity of total RNA (Bioanalyzer) Note: RNA degradation has a massive influence on the results of your experiment Poly(A) tailing, rRNA depletion and additional RNA treatment Perform poly(A)–tailing using the E. coli poly(A) polymerase (New England Biolabs): Incubate RNAs at 70°C for 2 min and snap cool it on a pre-chilled freezer block Incubate 5 µg RNA, 20 units poly(A) polymerase, 5 µl reaction buffer, 1 mM ATP for 15 min at 37°C in a total reaction volume of 50 µl. Stop and clean up the reaction following the RNeasy Micro clean-up protocol (Qiagen) Evaluate efficiency of poly(A)-tailing (Bioanalyzer, peaks of rRNAs) Note: Efficiency of poly(A)-tailing is a critical step, but may not work equally well in other organisms. Perform rRNA depletion, e.g. using the Pan-Prokaryote riboPOOL by siTOOLs (Clean-up can also be performed using the RNeasy protocol) Note: After depletion, only ~5% of the initial RNA input quantity are left. Perform additional treatment of your choice and clean-up, e.g. using the Terminator 5´-Phosphate-Dependent Exonuclease (TEX, Lucigen). Important: Before library preparation: Check extent of remaining buffer and DNA contamination that could have a negative impact on your library Check RNA size and quantity (Qubit) to determine molarities as accurately as possible Library preparation Libraries for Nanopore sequencing were prepared from poly(A)-tailed RNAs according to the protocols provided by ONT Critical steps: Input quality &amp; amount of RNA: Especially important for DRS, since you cannot get rid of excess amounts of RNA used as input. In that case, many transcripts that do not carry a motor protein are loaded onto the flowcell and overall have a negative impact on throughput/quality. Reverse transcription: Maxima RT H Minus performs well and can be adjusted to high GC content PCR for PCR-cDNA protocols: number of cycles adjusted to input amount (use minimal number cycles possible), extension time (adjust for longest transcripts you expect) Beads to cDNA ratio (PCR-cDNA): Enrichment for longer transcripts using a 0.5 ratio Molarity of ready-to-load library (check size &amp; quantity): Avoid overloading of your flowcells! We observed that especially small fragments lead to a poor translocation spped and quality of reads.”, “url”: “http://localhost:4000/rRNA_maturation/sample_preparation/”, “relUrl”: “/sample_preparation/” }, “16”: { “id”: “16”, “title”: “”, “content”: “{ {% for page in site.html_pages %}{% if page.search_exclude != true %}”{{ forloop.index0 }}”: { “id”: “{{ forloop.index0 }}”, “title”: “{{ page.title | replace: ‘&amp;’, ‘&amp;’ }}”, “content”: “{{ page.content | markdownify | strip_html | escape_once | remove: ‘’ | remove: ‘’ | remove: ‘—’ | replace: ‘', ‘ ‘ | normalize_whitespace }}”, “url”: “{{ page.url | absolute_url }}”, “relUrl”: “{{ page.url }}” }{% unless forloop.last %},{% endunless %} {% endif %}{% endfor %} }”, “url”: “http://localhost:4000/rRNA_maturation/assets/js/search-data/”, “relUrl”: “/assets/js/search-data/” }, “17”: { “id”: “17”, “title”: “Sequencing”, “content”: “Sequencing Perform sequencing using the recommended scripts in MinKNOW for the kit/barcode combination of your choice Enable live-basecalling to monitor read quality and translocation speed Speed/Quality drops (maybe due to many short reads)? Refuel flow cells as recommended by ONT After run: Wash flowcells and re-use with other barcode set, adjusted starting voltage to account for voltage drift”, “url”: “http://localhost:4000/rRNA_maturation/sequencing/”, “relUrl”: “/sequencing/” }, “18”: { “id”: “18”, “title”: “Detection of transcript boundaries”, “content”: “Detection of transcript boundaries 5´end detection 3´end detection The determination of enriched 5´and 3´ends was carried out in the same way, but independently of each other, and is briefly explained in the following: First, strand-specific read ends in bedgraph format were created from BAM files using bedtools genomecov (-5 or -3 option, -bga) Next, the previously published Termseq_peaks script was used to call peaks for each sample individually without including replicates (https://github.com/NICHD-BSPC/termseq-peaks) This script is based on scipy.signal.find_peaks, which is running in the background of Termseq_peaks with lenient parameters (prominence=(None,None), width=(1,None), rel_height=0.75) However, we deliberately used Termseq_peaks since its ability to include replicates by applying an Irreproducible Discovery Rate method which can be applied to future studies For end detection, only the leniently called peaks in the narrowPeak file were used after adding the number of counts for each position using bedtools intersect. 5´end detection 5´end peak calling was performed in the following way: input=microbepore/data/mapped # perform tss detection for pychopper auto &gt; cutadapt_polyA &gt; SSP-cutadapt &gt; clipped or for raw mapped reads for file in ${input}/trimmed/<em>/</em>/<em>clipped.sorted.bam # || for file in ${input}/raw/</em>/<em>/</em>.sorted.bam do # file and folder names filename_extended=${file##<em>/} keyword=$(echo $filename_extended | cut -d"." -f 2) foldername=$(echo $filename_extended | cut -d"_" -f 1,2,3) filename=${filename_extended%%.</em>} # make directories mkdir microbepore/data/tss/trimmed mkdir microbepore/data/tss/trimmed/${foldername} output=microbepore/data/tss/trimmed/${foldername}/${filename} mkdir ${output} # step 1: calculate 5´positions for plus and minus strand bedtools genomecov -ibam ${file} -bga -5 -strand + &gt; ${output}/${filename}.plus.bedgraph bedtools genomecov -ibam ${file} -bga -5 -strand - &gt; ${output}/${filename}.minus.bedgraph # step 2: termseq peaks termseq_peaks ${output}/${filename}.plus.bedgraph ${output}/${filename}.plus.bedgraph –peaks ${output}/${filename}.plus.peaks –strand + termseq_peaks ${output}/${filename}.minus.bedgraph ${output}/${filename}.minus.bedgraph –peaks ${output}/${filename}.minus.peaks –strand - # step 3: add coverage information bedtools intersect -wao -a ${output}/${filename}.plus.peaks.oracle.narrowPeak -b ${output}/${filename}.plus.bedgraph &gt; ${output}/${filename}.plus.peaks.oracle.narrowPeak.counts bedtools intersect -wao -a ${output}/${filename}.minus.peaks.oracle.narrowPeak -b ${output}/${filename}.minus.bedgraph &gt; ${output}/${filename}.minus.peaks.oracle.narrowPeak.counts done 3´end detection 3´end peak calling was performed in the following way: input=microbepore/data/mapped # perform tts detection for pychopper auto &gt; cutadapt_polyA &gt; SSP-cutadapt &gt; clipped or for raw mapped reads for file in ${input}/trimmed/<em>/</em>/<em>clipped.sorted.bam # || for file in ${input}/raw/</em>/<em>/</em>.sorted.bam do filename_extended=${file##<em>/} keyword=$(echo $filename_extended | cut -d"." -f 2) foldername=$(echo $filename_extended | cut -d"_" -f 1,2,3) filename=${filename_extended%%.</em>} echo ${filename} mkdir microbepore/data/tts/trimmed mkdir microbepore/data/tts/trimmed mkdir microbepore/data/tts/trimmed/${foldername} output=microbepore/data/tts/trimmed/${foldername}/${filename} mkdir ${output} # step 1: calculate 3´positions for plus and minus strand bedtools genomecov -ibam ${file} -bga -3 -strand + &gt; ${output}/${filename}.plus.bedgraph bedtools genomecov -ibam ${file} -bga -3 -strand - &gt; ${output}/${filename}.minus.bedgraph # step 2: termseq peaks termseq_peaks ${output}/${filename}.plus.bedgraph ${output}/${filename}.plus.bedgraph –peaks ${output}/${filename}.plus.peaks –strand + termseq_peaks ${output}/${filename}.minus.bedgraph ${output}/${filename}.minus.bedgraph –peaks ${output}/${filename}.minus.peaks –strand - # step 3: add coverage information bedtools intersect -wao -a ${output}/${filename}.plus.peaks.oracle.narrowPeak -b ${output}/${filename}.plus.bedgraph &gt; ${output}/${filename}.plus.peaks.oracle.narrowPeak.counts bedtools intersect -wao -a ${output}/${filename}.minus.peaks.oracle.narrowPeak -b ${output}/${filename}.minus.bedgraph &gt; ${output}/${filename}.minus.peaks.oracle.narrowPeak.counts done”, “url”: “http://localhost:4000/rRNA_maturation/processing_analysis/transcript_boundaries/”, “relUrl”: “/processing_analysis/transcript_boundaries/” }</p><p>}</p><hr><footer><p><a href="#top" id="back-to-top">Back to top</a></p><p class="text-small text-grey-dk-100 mb-0">Copyright &copy; 2022 Felix Grünberger. Distributed by an <a href="https://github.com/felixgrunberger/rRNA_maturation/tree/master/LICENSE.txt">MIT license.</a></p><div class="d-flex mt-2"></div></footer></div></div><a href="#" id="search-button" class="search-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-search"></use></svg> </a><div class="search-overlay"></div></div>
